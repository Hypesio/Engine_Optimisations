#version 450

layout(local_size_x = 8, local_size_y = 8) in;

#include "utils.glsl"
#define max_layers 14


layout(binding = 0) uniform sampler2D in_color;
layout(r32i, binding = 0) uniform readonly iimage2D head_texture;
layout(binding = 1) uniform writeonly image2D out_image;

layout(std430, binding = 0) buffer LinkedList {
    PixelNode nodes[];
};

void order_list(PixelNode list[max_layers], int size)
{
    // Simple bubble sort for the moment
    int i, j;
    for (i = 0; i < size - 1; i++)
    {
        // Last i elements are already
        // in place
        for (j = 0; j < size - i - 1; j++) 
        {
            if (list[j].depth < list[j + 1].depth)
            {
                PixelNode tmp = list[j]; 
                list[j] = list[j + 1]; 
                list[j + 1] = tmp;
            }
        }
    }
}

void insertion_sort(PixelNode list[max_layers], int size, PixelNode element)
{
    for (int i = 0; i < size; i++)
    {
        if (list[i].depth < element.depth)
        {
            PixelNode prev = list[i];
            list[i] = element;
            for (int j = i + 1; j < size; j++)
            {
                PixelNode tmp = list[j];
                list[j] = prev; 
                prev = tmp;
            }
        }
    }
}

void main()
{
    // Get the tail of the list
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    int idx = imageLoad(head_texture, coord).x;

    if (idx >= 0) // No transparency element on this pixel
    {
        // Build the full list
        /*PixelNode full_list[max_layers];
        int list_id = 0;
        while (idx >= 0 && list_id < max_layers)
        {
            full_list[list_id++] = nodes[idx]; 
            idx = int(nodes[idx].prev);
        }
        int size = list_id;

        // Sort the list
        order_list(full_list, size);

        // Insertion sort all the remaining elements in list
        while(idx >= 0)
        {
            PixelNode to_add = nodes[idx];
            insertion_sort(full_list, max_layers, to_add);
            idx = int(to_add.prev);
        }*/

        // Blend all values
        vec4 node_color = nodes[idx].color;
        if (node_color.x == 0)
            node_color = vec4(1.0, 1.0, 1.0, 1.0);
        vec4 color = texelFetch(in_color, coord, 0) + node_color;
        /*int id = 0;
        while (id <= size)
        {
            // Simple additive blending -- Should be alpha blending for better result
            color += full_list[list_id++].color;
        }*/

        imageStore(out_image, coord, color);
    }
    else 
    {
        vec4 color = texelFetch(in_color, coord, 0);
        imageStore(out_image, coord, color);
    }

    
}
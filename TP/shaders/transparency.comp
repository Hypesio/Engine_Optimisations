#version 450

layout(local_size_x = 8, local_size_y = 8) in;

#include "utils.glsl"

layout(binding = 0) uniform sampler2D in_color;
layout(binding = 0) uniform readonly image2D tail_texture;
layout(binding = 1) uniform writeonly image2D out_color;

int max_layers = 14;

layout(binding = 2) buffer LinkedList {
    PixelNode nodes[];
}

void order_list(PixelNode[] list, int size)
{
    // Simple bubble sort for the moment
    int i, j;
    for (i = 0; i < size - 1; i++)
    {
        // Last i elements are already
        // in place
        for (j = 0; j < size - i - 1; j++) 
        {
            if (list[j].depth < list[j + 1].depth)
            {
                PixelNode tmp = list[j]; 
                list[j] = list[j + 1]; 
                list[j + 1] = tmp;
            }
        }
    }
}

void insertion_sort(PixelNode[] list, int size, PixelNode element)
{
    for (int i = 0; i < size; i++)
    {
        if (list[i].depth < element.depth)
        {
            PixelNode prev = list[i];
            list[i] = element;
            for (int j = i + 1; j < size; j++)
            {
                PixelNode tmp = list[j];
                list[j] = prev; 
                prev = tmp;
            }
        }
    }
}

void main()
{
    // Get the tail of the list
    uint idx = imageLoad(tail_texture, gl_GlobalInvocationID.xy);

    if (idx < 0) // No transparency element on this pixel
        return;
    
    // Build the full list
    PixelNode full_list[max_layers];
    int list_id = 0;
    while (idx >= 0 && size < max_layers)
    {
        full_list[list_id++] = nodes[idx]; 
        idx = nodes.prev;
    }
    size = list_id;

    // Sort the list
    order_list(full_list, size);

    // Insertion sort all the remaining elements in list
    while(idx >= 0)
    {
        PixelNode to_add = nodes[idx];
        insertion_sort(list, max_layers, to_add);
        idx = to_add.prev;
    }

    // Blend all values
    vec4 color = texelFetch(in_color, gl_GlobalInvocationID.xy, 0);
    int id = 0;
    while (id <= size)
    {
        // Simple additive blending
        color += full_list[id_list++].color;
    }

    imageStore(out_color, coord);
}